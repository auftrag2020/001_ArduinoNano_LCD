import re
import csv
from openpyxl import Workbook
from registerFile import Register_File
from lib.fileHelper import *
from typing import Dict, List


class Register_Tools:
    def __init__(self, regdef_file_path):
        self.fileHelper = FileHelper()        
        self.regdef_file_path = regdef_file_path
        pass   
    
    #######################################################################################
    # 2024-10-28 Siwei:
    # all these codes are generated by openAI, I don't understand the parser rules at all
    def get_union_pattern(self, reg_type):
        return rf'typedef\s+union\s+\{{.*?\}}\s+{re.escape(reg_type)};'
    
    def get_root_struct_pattern(self):
        # Define and return the regex pattern for matching struct definitions
        return re.compile(r'typedef\s+volatile\s+struct\s+_(\w+)', re.MULTILINE)
    
    def get_struct_pattern(self, module_name):
        # Ensure that the module name matches the expected pattern
        return re.compile(
            rf'typedef\s+volatile\s+struct\s+_{re.escape(module_name)}\s*\{{(.*?)\}}',
            re.DOTALL | re.MULTILINE  # DOTALL allows '.' to match newlines
        )        
    
    def get_struct_member_pattern(self):
        return re.compile(r'\s*(\w+)\s+(\w+(\[\d+\])?)\s*;')
    #######################################################################################
    
    def get_root_reg_type(self):
        # Open and read the regdef.h file
        with open(self.regdef_file_path, 'r') as file:
            content = file.read()

        # Prepare the regex pattern to find all struct definitions
        struct_pattern = self.get_root_struct_pattern()

        # Find all matches for struct types
        structs = struct_pattern.findall(content)

        # If structs are found, return the last one as a string; otherwise, return an empty string
        if structs:
            last_struct = structs[-1]  # Get the last struct type
            return f"{last_struct}"  # Return as a readable string
        else:
            return ""  # Return an empty string if no structs found

    def get_reg_typedef(self, reg_type):
        result = None
        # Open and read the regdef file
        with open(self.regdef_file_path, 'r') as file:
            content = file.read()
        
        # Define regex patterns for typedef union and typedef struct
        self.reg_type = reg_type
        union_pattern = self.get_union_pattern(reg_type)
        struct_pattern = self.get_struct_pattern(reg_type)
        
        # Check if the reg_type matches a typedef union
        if re.search(union_pattern, content, re.DOTALL):
            result = 'union'
        # Check if the reg_type matches a typedef struct
        elif re.search(struct_pattern, content, re.DOTALL):
            result = 'struct'            
        else:
            result = None
        # Return None if reg_type is neither found as union nor struct
        return result
    
    def is_extraction_necessary(self, reg_name):
        result = False
        if re.search(r'\[\d*\]', reg_name):
            result = True
        else:
            result = False
        return result
    
    def extract_root_reg(self, root_reg:dict, extract_depth:int):
        extract_data = root_reg
        # extract_module_name is not needed to change
        extract_module_name = f"{root_reg['module_name']}_extraction_level_{extract_depth}"
        extract_members = []
        extract_title   = dict(root_reg['titles'])        

        extract_type = []        
        for index in range (extract_depth+1):
            for member in list(root_reg['members']):
                if isinstance(member, dict):
                    #do nothing
                    pass
                else:
                    member = dict(member)
                    
                # Check if reg_name starts with "reserved_"
                if member['reg_name'].startswith("reserved_"):
                    extract_type = member['reg_type']
                else:
                    # Check if reg_name contains "[]" (array)
                    if self.is_extraction_necessary(member['reg_name']) == False:
                        extract_type = member['reg_type'] + "_Bits"
                    else: # not array
                        # ToDo: recursive extraction needed
                        extract_type_key = member['reg_type']
                            
                        
                        
                
                member.update({f"extract_level_{index}" : extract_type})
                extract_members.append(member)
            
            extract_title.update(
                {f"extraction_level_{index}" : f"Extraction Level {index}"}
            )
            
        extract_data.update({
            "module_name": extract_module_name,
            "titles"    : extract_title,    
            "members"   : extract_members     
        })
        
        return extract_data
    
    def get_reg_data(self, module_name):
        with open(self.regdef_file_path, 'r') as file:
            file_content = file.read()
        
        # Pattern to match the unique struct definition based on module_name
        struct_pattern = self.get_struct_pattern(module_name)
        
        # Use search instead of findall to get a single match
        match = struct_pattern.search(file_content)

        # Check if a match was found
        if match:
            struct = match.group(0)  # Get the matched struct definition
        else:
            struct = None  # Handle the case where no struct is found
        
        # Prepare the summary of members
        reg_members = []
        
        # Only proceed if a struct was found
        if struct:
            # Pattern to extract members of the struct
            pattern_member = self.get_struct_member_pattern()
            members = pattern_member.findall(struct)  # Extract members from the struct
            
            # Be aware of root reg struct text sequence, first reg_type, then reg_name
            for reg_type, reg_name, reg_comment in members:
                reg_members.append({
                    "reg_name": reg_name,  # Include array notation in reg_name
                    "reg_type": reg_type,
                    # 'reg_comment': reg_comment  # Uncomment if you want to include comments
                })
        
        titles = {
            "reg_name": "Register Name",
            "reg_type": "Register Type",
        }
        
        # Combine results into a single variable
        result = {
            "module_name": module_name,
            "titles": titles,
            "members": reg_members
        }
        return result    

    # def extract_root_reg_recursive(self, ext_root_reg: dict, ext_extract_depth: list, ext_recursive: list):
    #     # Check if extraction is necessary for any member
    #     extract_types = [member['reg_name'] for member in ext_root_reg['members']]

    #     extraction_needed = any(self.is_extraction_necessary(reg_name) == "yes" for reg_name in reg_names)                
    #     ext_recursive[0] = extraction_needed

    #     # Continue recursion if necessary
    #     if ext_recursive[0]:
    #         self.extract_root_reg_recursive(ext_root_reg, ext_extract_depth, ext_recursive)
    #     else:
    #         # Increment extraction depth
    #         ext_extract_depth[0] += 1
    #         print("ext_extract_depth:", ext_extract_depth[0])
    #         extract_module_name = f"{ext_root_reg['module_name']}_extraction_level_{ext_extract_depth[0]}"
    #         extract_members = []
    #         extract_title = dict(ext_root_reg['titles'])

    #         # Update each member with extraction level
    #         for member in ext_root_reg['members']:
    #             # Ensure member is a dictionary
    #             member = dict(member) if not isinstance(member, dict) else member

    #             if self.is_extraction_necessary(member['reg_name']) == "no":
    #                 # member is either reserved_ or single var (not an array)
    #                 extract_type = member['reg_type'] + "_Bits"
    #             else:       
    #                 # member is an array
    #                 extract_type = member['reg_type'] + '_Bits'

    #             # Add extraction level info to the member
    #             member.update({f"extract_level_{ext_extract_depth[0]}": extract_type})
    #             extract_members.append(member)

    #         # Update titles and module name directly in `ext_root_reg`
    #         extract_title.update(
    #             {f"extraction_level_{ext_extract_depth[0]}": f"Extraction Level {ext_extract_depth[0]}"}
    #         )
    #         ext_root_reg.update({
    #             "module_name": extract_module_name,
    #             "titles": extract_title,
    #             "members": extract_members
    #         })